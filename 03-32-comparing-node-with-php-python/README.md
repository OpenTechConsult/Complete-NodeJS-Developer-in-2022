# Comparing Node.js with PHP and Python

As we are learning about the internals of Node.js, it's worth taking a step back and considering how is what we're learning about Node.js different than languages like php and python?

We've already seen that a crucial difference with **Java**, **C** and **C++**, is that those languages support multithreaded programming.
But PHP and Python are both high level, easy to use single threaded programming languages just like JavaScript.

So what the difference ? If we think back in the days (say twenty years ago), when it came to the web, php and python followed a more traditional model where they needed a web server (something like **Apache**) to handle multiple request coming in. **Apache** was a big hit and had a lot going for it, including that it was free and open source.

With this web server, any request to our server (asking from some data) was blocking. So it will handle the request in a new thread. Because each thread will be blocked by our blocking **PHP** or **Python** code, we will have to spawn another thread in **Apache** to handle the next requests, and the next request after that, and so on and so forth. Each client talking to a server will get its own thread. Which means that our server needs a lot of threads, with a lot of resources used by those threads. The server will be able to handle as many connection as it could thread. That means creating a websites that can serve millions of users is quiet difficult and expensive. Serving a site like Google or Facebook that get lot of traffic would crash pretty quickly.

In 2009, Node.JS became popular because of its model of non-blocking IO that we talked about. Taking in all of these requests, in the Node.js model, we take the request into the JavaScript engine (remember that the engine is single threaded). And for each request coming in, we quickly pass it off from the V8 engine to be handled by libuv (which use an even loop). Even though our JavaScript code run in a single thread, Node.js allows us to handle thousands of concurrent requests by delegating or passing off the majority of the work. It passes this work off specifically to the multiple thread in the thread pool. And whenever possible skipping the thread pool and talking directly to the operating system. Because the operating system is already multithreaded these works can be done without blocking the server. All of these happens in the Node.js process. There is no need for additional web server like apache to create thousands of threads.

Looking back on things, php model worked pretty well, but for many connections at the same time Node.js IO model works really really well. Now looking forward, things these days are changing and the concept of non-blocking IO is been used more and more. Python for instance has integrated support for running an event loop out of the box; bringing it a step closer to Node. However, none of these languages that we've talked about make it as easy to work with asynchronous programming as JavaScript and Node. Because Node.js was build specifically to do asynchronous non-blocking IO really simply and efficiently. 

As a side note, we can put a web server like Apache ou NGINX server in front of a node server. And it's actually a good idea to use them together sometimes if you have a larger and more complex application, we are going to handle thousands of concurrent requests. But it really depends on what we're building. We'll look at performance when we'll build our final project. But next, we'll see when it's best to use Node.js.
